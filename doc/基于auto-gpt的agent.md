# 基于 auto-gpt 的 agent 以什么样的形式存在

## auto-gpt 有什么

- auto-gpt 的基本元素——block

在 auto-gpt 中，系统具备的基本能力被抽象成一个一个的 block，这些 block 根据能力的不同被划分到不同的类别。

![](http://192.168.99.63:3000/uploads/upload_c16f9039967bb72d16f128d8ba0cecd9.png)

- graph（Agent）

基于这些 block，我们可以将它们拖放到画布上，形成一个个相互连接的 node，这被称做 graph，一个 graph 可以看作一个 Agent

> 一个根据提示词创建图片的 Agent

![](http://192.168.99.63:3000/uploads/upload_75fc7a212ea0b1f2abac685daaa9e163.png)

> 一个复杂点的 Agent（用于生成一个 python 文件，这个 python 文件是一个 auto-gpt 的 block 类）

![](http://192.168.99.63:3000/uploads/upload_9d8e3e2d7bc5f21430c841dae843b350.png)

在上图左侧是 agent 的输入部分，主要从 github 上拉取相应的示例代码，md 说明文档作为上下文，然后传递给 ai node：

![](http://192.168.99.63:3000/uploads/upload_bc68a90400f442078c580f56775d76e9.png)

这个 Agent 的核心是 ai 生成块，将左侧的输入合成为一个完整的提示词传递给 Ai：

![](http://192.168.99.63:3000/uploads/upload_a92f0c462b4355570793bce6fdd22035.png)

最后，将 ai 生成的内容，做一些处理，作为 agent 的输出

![](http://192.168.99.63:3000/uploads/upload_b50db675f1001fe525c0626a03d986c3.png)

## auto-gpt 的特点

- 将 agent 以 graph 的形式组织，基本能力以 block 作为载体，如果系统不具备某种能力，则需要自行编写相应的 block

- 在 auto-gpt 中，将 Ai 的能力看成是一个黑盒，用户在 ai 之外对功能编排，不侵入 ai 内部，将 ai 作为一个第三方供应商来调用。

## 总结

在自动代码生成领域，当前的系统，如 Auto-GPT，往往将 AI 的能力视作一个黑盒，用户只能在 AI 外部进行功能编排，而无法深入控制和修改 AI 的内部逻辑。这种设计虽然简化了用户的操作流程，但也极大限制了用户充分利用本地知识和环境的能力。尤其是在开发过程中，代码生成任务经常依赖于特定的业务逻辑、已有的代码库以及项目的技术栈，而这些本地化的信息对于 AI 来说是无法直接访问和理解的。用户不得不将这些本地信息手动传递给 AI 或编写额外的 block 来补充能力，这无疑增加了系统的复杂性和开发者的负担。

相较于传统的 AI 模型黑盒模式，一个更加灵活的架构应允许用户与 AI 的内部进行更深度的交互，甚至能够根据项目的需求灵活定制 AI 的行为，充分利用本地数据与已有资源。例如，代码生成模型应该能够自动访问并理解项目中的上下文、库文件和已有代码结构，从而提高生成代码的准确性和一致性。然而，当前的系统往往无法在本地知识和通用 AI 能力之间建立深度连接，导致生成的代码与实际需求之间产生脱节，进而增加了后续调试和优化的工作量。

因此，未来的自动代码生成工具不仅需要具备强大的 AI 能力，更要提供一种机制，使得本地数据与 AI 模型能够充分融合，打破这种"黑盒"限制，从而实现更为精准、实用的代码生成过程。
